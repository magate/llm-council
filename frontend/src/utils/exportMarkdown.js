/**
 * Formats a council response message as markdown
 * @param {Object} message - The assistant message object with stage1, stage2, stage3, and metadata
 * @param {string} userQuestion - The user's question that preceded this response
 * @returns {string} - Formatted markdown string
 */
export function formatCouncilResponseAsMarkdown(message, userQuestion) {
  let markdown = '';

  // Header
  markdown += '# LLM Council Response\n\n';

  if (userQuestion) {
    markdown += `## Question\n\n${userQuestion}\n\n`;
  }

  markdown += '---\n\n';

  // Stage 1: Individual Responses
  if (message.stage1 && message.stage1.length > 0) {
    markdown += '## Stage 1: Individual Model Responses\n\n';

    message.stage1.forEach((response, index) => {
      markdown += `### ${response.model}\n\n`;
      markdown += `${response.content}\n\n`;

      if (response.reasoning_details) {
        markdown += `**Reasoning Details:**\n\n${response.reasoning_details}\n\n`;
      }

      markdown += '---\n\n';
    });
  }

  // Stage 2: Peer Rankings
  if (message.stage2 && message.stage2.length > 0) {
    markdown += '## Stage 2: Peer Evaluations\n\n';

    // Add note about anonymization
    markdown += '*Note: In Stage 2, models evaluated responses anonymously (as "Response A", "Response B", etc.) to prevent bias. Model names shown below are revealed for transparency.*\n\n';

    // Add aggregate rankings if available
    if (message.metadata?.aggregate_rankings && message.metadata.aggregate_rankings.length > 0) {
      markdown += '### Aggregate Rankings\n\n';
      markdown += 'Average positions across all peer evaluations:\n\n';

      message.metadata.aggregate_rankings.forEach((item, index) => {
        const modelName = message.metadata.label_to_model?.[item.label] || item.label;
        const avgPos = item.average_position != null ? item.average_position.toFixed(2) : 'N/A';
        const votes = item.vote_count != null ? item.vote_count : 0;
        markdown += `${index + 1}. **${modelName}** (${item.label}) - Average position: ${avgPos} (${votes} votes)\n`;
      });

      markdown += '\n';
    }

    markdown += '### Individual Evaluations\n\n';

    message.stage2.forEach((ranking, index) => {
      markdown += `#### Evaluation by ${ranking.model}\n\n`;

      // Add de-anonymized content if we have the mapping
      let evaluationText = ranking.content;
      if (message.metadata?.label_to_model) {
        // Replace Response labels with actual model names in bold
        Object.entries(message.metadata.label_to_model).forEach(([label, modelName]) => {
          const regex = new RegExp(`\\b${label}\\b`, 'g');
          evaluationText = evaluationText.replace(regex, `**${modelName}** (${label})`);
        });
      }

      markdown += `${evaluationText}\n\n`;

      if (ranking.parsed_ranking && ranking.parsed_ranking.length > 0) {
        markdown += '**Extracted Ranking:**\n\n';
        ranking.parsed_ranking.forEach((label, idx) => {
          const modelName = message.metadata?.label_to_model?.[label] || label;
          markdown += `${idx + 1}. ${modelName} (${label})\n`;
        });
        markdown += '\n';
      }

      markdown += '---\n\n';
    });
  }

  // Stage 3: Final Synthesis
  if (message.stage3) {
    markdown += '## Stage 3: Final Synthesis\n\n';
    markdown += `${message.stage3.content}\n\n`;

    if (message.stage3.reasoning_details) {
      markdown += `**Reasoning Details:**\n\n${message.stage3.reasoning_details}\n\n`;
    }
  }

  // Footer
  markdown += '---\n\n';
  markdown += `*Generated by LLM Council on ${new Date().toLocaleString()}*\n`;

  return markdown;
}

/**
 * Triggers a download of the markdown content as a file
 * @param {string} markdown - The markdown content to download
 * @param {string} filename - The filename for the download (optional)
 */
export function downloadMarkdown(markdown, filename = 'council-response.md') {
  const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
