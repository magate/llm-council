/**
 * Formats a council response message as markdown
 * @param {Object} message - The assistant message object with stage1, stage2, stage3, and metadata
 * @param {string} userQuestion - The user's question that preceded this response
 * @returns {string} - Formatted markdown string
 */
export function formatCouncilResponseAsMarkdown(message, userQuestion) {
  let markdown = '';

  // Header
  markdown += '# LLM Council Response\n\n';

  if (userQuestion) {
    markdown += `## Question\n\n${userQuestion}\n\n`;
  }

  markdown += '---\n\n';

  // Stage 1: Individual Responses
  if (message.stage1 && message.stage1.length > 0) {
    markdown += '## Stage 1: Individual Model Responses\n\n';

    message.stage1.forEach((response, index) => {
      markdown += `### ${response.model}\n\n`;
      markdown += `${response.response}\n\n`;

      if (response.reasoning_details) {
        markdown += `**Reasoning Details:**\n\n${response.reasoning_details}\n\n`;
      }

      markdown += '---\n\n';
    });
  }

  // Stage 2: Peer Rankings
  if (message.stage2 && message.stage2.length > 0) {
    markdown += '## Stage 2: Peer Evaluations\n\n';

    // Add note about anonymization
    markdown += '*Note: In Stage 2, models evaluated responses anonymously (as "Response A", "Response B", etc.) to prevent bias. Model names shown below are revealed for transparency.*\n\n';

    // Add aggregate rankings if available
    if (message.metadata?.aggregate_rankings && message.metadata.aggregate_rankings.length > 0) {
      markdown += '### Aggregate Rankings\n\n';
      markdown += 'Average positions across all peer evaluations:\n\n';

      message.metadata.aggregate_rankings.forEach((item, index) => {
        const modelName = message.metadata.label_to_model?.[item.label] || item.label;
        const avgPos = item.average_position != null ? item.average_position.toFixed(2) : 'N/A';
        const votes = item.vote_count != null ? item.vote_count : 0;
        markdown += `${index + 1}. **${modelName}** (${item.label}) - Average position: ${avgPos} (${votes} votes)\n`;
      });

      markdown += '\n';
    }

    markdown += '### Individual Evaluations\n\n';

    message.stage2.forEach((ranking, index) => {
      markdown += `#### Evaluation by ${ranking.model}\n\n`;

      // Add de-anonymized content if we have the mapping
      let evaluationText = ranking.ranking;
      if (message.metadata?.label_to_model) {
        // Replace Response labels with actual model names in bold
        Object.entries(message.metadata.label_to_model).forEach(([label, modelName]) => {
          const regex = new RegExp(`\\b${label}\\b`, 'g');
          evaluationText = evaluationText.replace(regex, `**${modelName}** (${label})`);
        });
      }

      markdown += `${evaluationText}\n\n`;

      if (ranking.parsed_ranking && ranking.parsed_ranking.length > 0) {
        markdown += '**Extracted Ranking:**\n\n';
        ranking.parsed_ranking.forEach((label, idx) => {
          // Only show model name if we have the mapping, otherwise just show the label
          if (message.metadata?.label_to_model?.[label]) {
            const modelName = message.metadata.label_to_model[label];
            markdown += `${idx + 1}. ${modelName} (${label})\n`;
          } else {
            markdown += `${idx + 1}. ${label}\n`;
          }
        });
        markdown += '\n';
      }

      markdown += '---\n\n';
    });
  }

  // Stage 3: Final Synthesis
  if (message.stage3) {
    markdown += '## Stage 3: Final Synthesis\n\n';
    markdown += `${message.stage3.response}\n\n`;

    if (message.stage3.reasoning_details) {
      markdown += `**Reasoning Details:**\n\n${message.stage3.reasoning_details}\n\n`;
    }
  }

  // Footer
  markdown += '---\n\n';
  markdown += `*Generated by LLM Council on ${new Date().toLocaleString()}*\n`;

  return markdown;
}

/**
 * Formats an entire conversation as markdown
 * @param {Object} conversation - The conversation object with messages array
 * @returns {string} - Formatted markdown string
 */
export function formatConversationAsMarkdown(conversation) {
  let markdown = '';

  // Header
  markdown += '# LLM Council Conversation Transcript\n\n';

  if (conversation.title) {
    markdown += `**Title:** ${conversation.title}\n\n`;
  }

  if (conversation.created_at) {
    const date = new Date(conversation.created_at).toLocaleString();
    markdown += `**Created:** ${date}\n\n`;
  }

  markdown += '---\n\n';

  // Process all messages
  if (conversation.messages && conversation.messages.length > 0) {
    conversation.messages.forEach((msg, index) => {
      if (msg.role === 'user') {
        markdown += `## User Question ${Math.floor(index / 2) + 1}\n\n`;
        markdown += `${msg.content}\n\n`;
        markdown += '---\n\n';
      } else if (msg.role === 'assistant') {
        markdown += `## Council Response ${Math.floor(index / 2) + 1}\n\n`;

        // Stage 1
        if (msg.stage1 && msg.stage1.length > 0) {
          markdown += '### Stage 1: Individual Model Responses\n\n';
          msg.stage1.forEach((response) => {
            markdown += `**${response.model}:**\n\n`;
            markdown += `${response.response}\n\n`;
          });
          markdown += '\n';
        }

        // Stage 2
        if (msg.stage2 && msg.stage2.length > 0) {
          markdown += '### Stage 2: Peer Evaluations\n\n';

          // Aggregate rankings if available
          if (msg.metadata?.aggregate_rankings && msg.metadata.aggregate_rankings.length > 0) {
            markdown += '**Aggregate Rankings:**\n\n';
            msg.metadata.aggregate_rankings.forEach((item, idx) => {
              const modelName = msg.metadata.label_to_model?.[item.label] || item.label;
              const avgPos = item.average_position != null ? item.average_position.toFixed(2) : 'N/A';
              const votes = item.vote_count != null ? item.vote_count : 0;
              markdown += `${idx + 1}. ${modelName} - Avg position: ${avgPos} (${votes} votes)\n`;
            });
            markdown += '\n';
          }

          msg.stage2.forEach((ranking) => {
            markdown += `**${ranking.model} Evaluation:**\n\n`;

            // De-anonymize if we have the mapping
            let evaluationText = ranking.ranking;
            if (msg.metadata?.label_to_model) {
              Object.entries(msg.metadata.label_to_model).forEach(([label, modelName]) => {
                const regex = new RegExp(`\\b${label}\\b`, 'g');
                evaluationText = evaluationText.replace(regex, `**${modelName}**`);
              });
            }

            markdown += `${evaluationText}\n\n`;
          });
        }

        // Stage 3
        if (msg.stage3) {
          markdown += '### Stage 3: Final Synthesis\n\n';
          markdown += `${msg.stage3.response}\n\n`;
        }

        markdown += '---\n\n';
      }
    });
  }

  // Footer
  markdown += `*Transcript generated on ${new Date().toLocaleString()}*\n`;

  return markdown;
}

/**
 * Triggers a download of the markdown content as a file
 * @param {string} markdown - The markdown content to download
 * @param {string} filename - The filename for the download (optional)
 */
export function downloadMarkdown(markdown, filename = 'council-response.md') {
  const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
